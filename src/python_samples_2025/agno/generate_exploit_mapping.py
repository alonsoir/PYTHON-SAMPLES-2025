# generate_exploit_mapping.py
import json
import os
import subprocess
import re
import time
from typing import Dict, List
from datetime import datetime

import logging

# Configuración de logging
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger("ExploitMappingGenerator")
results_dir = "/results"
os.makedirs(results_dir, exist_ok=True)
log_file = "/results/mapping_generator.log"
file_handler = logging.FileHandler(log_file)
file_handler.setLevel(logging.DEBUG)
formatter = logging.Formatter('%(asctime)s [%(name)s] %(levelname)s: %(message)s')
file_handler.setFormatter(formatter)
logger.addHandler(file_handler)


class ExploitMappingGenerator:
    def __init__(self):
        self.msfconsole_path = "/usr/bin/msfconsole"
        self.mapping_file = "/results/exploit_mapping.json"
        self.exploit_mapping: Dict[str, str] = {}
        self.db_config = {
            "host": "postgres",
            "port": "5432",
            "database": "msf",
            "username": "msf",
            "password": "msfpassword"
        }

    def wait_for_postgres(self):
        """Espera a que PostgreSQL esté listo."""
        logger.info("Esperando a que PostgreSQL esté listo...")
        max_attempts = 30
        for attempt in range(max_attempts):
            try:
                cmd = [
                    "pg_isready",
                    "-h", self.db_config["host"],
                    "-p", self.db_config["port"],
                    "-U", self.db_config["username"],
                    "-d", self.db_config["database"]
                ]
                env = os.environ.copy()
                env["PGPASSWORD"] = self.db_config["password"]
                result = subprocess.run(
                    cmd,
                    capture_output=True,
                    text=True,
                    timeout=10,
                    env=env,
                    check=True
                )
                logger.debug(f"Salida de pg_isready: {result.stdout}")
                logger.info("PostgreSQL está listo")
                return
            except subprocess.CalledProcessError as e:
                logger.debug(f"PostgreSQL no está listo (intento {attempt + 1}/{max_attempts}): {e.stderr}")
                time.sleep(2)
        raise RuntimeError("No se pudo conectar a PostgreSQL después de varios intentos")

    def initialize_msfdb(self):
        """Configura e inicializa la base de datos de Metasploit manualmente."""
        try:
            # Esperar a que PostgreSQL esté listo
            self.wait_for_postgres()

            # Crear el archivo de configuración de la base de datos para Metasploit
            msf_config_dir = "/root/.msf4"
            os.makedirs(msf_config_dir, exist_ok=True)
            db_config_file = os.path.join(msf_config_dir, "database.yml")

            config_content = f"""
production:
  adapter: postgresql
  database: {self.db_config['database']}
  username: {self.db_config['username']}
  password: {self.db_config['password']}
  host: {self.db_config['host']}
  port: {self.db_config['port']}
  pool: 5
  timeout: 5
"""
            with open(db_config_file, "w") as f:
                f.write(config_content)
            logger.info(f"Archivo de configuración de la base de datos creado en {db_config_file}")

            # Probar la conexión a la base de datos con msfconsole
            logger.info("Probando la conexión a la base de datos con msfconsole...")
            cmd = [
                self.msfconsole_path,
                "-q",
                "-x",
                "db_status; exit"
            ]
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=60
            )
            logger.debug(f"Salida de msfconsole (db_status): {result.stdout}")
            logger.debug(f"Errores de msfconsole (db_status): {result.stderr}")
            if "connected to" not in result.stdout.lower():
                raise RuntimeError("No se pudo conectar a la base de datos con msfconsole")
            logger.info("Conexión a la base de datos verificada con éxito")

        except Exception as e:
            logger.error(f"Error al inicializar la base de datos de Metasploit: {e}")
            raise

    def get_searchsploit_exploits(self) -> List[Dict]:
        """Obtiene la lista de exploits de searchsploit en formato JSON."""
        try:
            cmd = ["searchsploit", "-j", '--exclude="dos"']
            logger.debug(f"Ejecutando comando: {' '.join(cmd)}")
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=60,
                check=True
            )

            exploits = json.loads(result.stdout).get("RESULTS_EXPLOIT", [])
            logger.info(f"Encontrados {len(exploits)} exploits en searchsploit")
            return exploits
        except subprocess.CalledProcessError as e:
            logger.error(f"Error al ejecutar searchsploit: {e.stderr}")
            raise
        except json.JSONDecodeError as e:
            logger.error(f"Error al parsear la salida de searchsploit como JSON: {e}")
            raise
        except Exception as e:
            logger.error(f"Error al obtener exploits de searchsploit: {e}")
            raise

    def get_metasploit_modules(self) -> List[Dict]:
        """
        Obtiene la lista de módulos de Metasploit ejecutando un script en msfconsole.
        Devuelve una lista de diccionarios con nombre, descripción, plataformas y referencias.
        """
        try:
            # Crear un script temporal .rc para msfconsole
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            rc_script = f"/tmp/list_modules_{timestamp}.rc"
            output_file = f"/tmp/msf_modules_{timestamp}.txt"
            with open(rc_script, "w") as f:
                f.write("ruby\n")  # Entrar en modo Ruby
                f.write("File.open('#{output_file}', 'w') do |f|\n")
                f.write("  sleep 5  # Esperar a que el framework esté listo\n")
                f.write("  framework.modules.each do |name, mod|\n")
                f.write("    next unless name.start_with?('exploit/')\n")
                f.write("    begin\n")
                f.write("      m = framework.modules.create(name)\n")
                f.write("      if m\n")
                f.write("        refs = m.references.map { |r| r.to_s }.join(',')\n")
                f.write("        platforms = m.platform.join(',')\n")
                f.write("        f.puts \"#{name}|#{m.description}|#{platforms}|#{refs}\"\n")
                f.write("      else\n")
                f.write("        f.puts \"ERROR: #{name}|No se pudo crear el módulo\"\n")
                f.write("      end\n")
                f.write("    rescue => e\n")
                f.write("      f.puts \"ERROR: #{name}|#{e.message}\"\n")
                f.write("    end\n")
                f.write("  end\n")
                f.write("end\n")
                f.write("exit\n")

            logger.debug(f"Script Ruby creado en {rc_script}")

            # Ejecutar msfconsole con el script .rc
            command = f"{self.msfconsole_path} -q -r {rc_script}"
            logger.debug(f"Ejecutando comando: {command}")
            process = subprocess.run(
                command,
                shell=True,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                timeout=600
            )
            logger.debug(f"Salida de msfconsole (stdout): {process.stdout}")
            logger.debug(f"Errores de msfconsole (stderr): {process.stderr}")

            # Verificar si el archivo de salida existe
            if not os.path.exists(output_file):
                logger.error(f"El archivo de salida {output_file} no se creó")
                raise RuntimeError(f"El archivo de salida {output_file} no se creó")

            # Leer la salida
            modules = []
            with open(output_file, "r") as f:
                content = f.read()
                logger.debug(f"Contenido de {output_file}:\n{content}")
                for line in f:
                    line = line.strip()
                    if line.startswith("MODULE:"):
                        parts = line.split("|")
                        if len(parts) >= 4:
                            name = parts[1]
                            description = parts[2]
                            platforms = parts[3].split(",")
                            references = parts[4].split(",") if len(parts) > 4 else []
                            modules.append({
                                "name": name,
                                "description": description,
                                "platforms": platforms,
                                "references": references
                            })
                    elif line.startswith("ERROR:"):
                        logger.warning(f"Error en módulo: {line}")

            # Limpiar archivos temporales
            os.remove(rc_script)
            os.remove(output_file)

            logger.info(f"Encontrados {len(modules)} módulos de Metasploit")
            return modules
        except subprocess.CalledProcessError as e:
            logger.error(f"Error al listar módulos de Metasploit: {e.stderr}")
            raise
        except Exception as e:
            logger.error(f"Error al obtener módulos de Metasploit: {e}")
            raise

    def map_exploits_to_modules(self, exploits: List[Dict], modules: List[Dict]) -> Dict[str, str]:
        """
        Mapea exploits de searchsploit a módulos de Metasploit usando coincidencias de palabras clave.
        """
        mapping = {}
        for exploit in exploits:
            title = exploit.get("Title", "").lower()
            edb_id = exploit.get("EDB-ID", "unknown")
            platform = exploit.get("Platform", "").lower()

            # Palabras clave del título
            keywords = set(re.findall(r'\w+', title))
            keywords.update([platform])  # Agregar la plataforma como palabra clave

            # Buscar coincidencias en los módulos de Metasploit
            best_match = None
            best_score = 0

            for module in modules:
                module_name = module["name"].lower()
                description = module["description"].lower()
                module_platforms = [p.lower() for p in module["platforms"]]
                references = [r.lower() for r in module["references"]]

                # Calcular un puntaje de coincidencia
                score = 0
                # Coincidencia en el título/descripción
                for keyword in keywords:
                    if keyword in module_name or keyword in description:
                        score += 2
                    if keyword in " ".join(module_platforms):
                        score += 1
                # Coincidencia en referencias (e.g., EDB-ID)
                if f"edb-{edb_id}" in references:
                    score += 5  # Alta prioridad si hay coincidencia de EDB-ID

                if score > best_score:
                    best_score = score
                    best_match = module["name"]

            # Si se encontró una coincidencia razonable, agregar al mapeo
            if best_score >= 3:  # Umbral de coincidencia
                # Normalizar la clave del mapeo
                key = " ".join(
                    sorted([k for k in keywords if k not in ["exploit", "vulnerability", "remote", "local"]])).strip()
                if key:
                    mapping[key] = best_match
                    logger.debug(f"Mapeado '{key}' (EDB-ID: {edb_id}) a '{best_match}' (score: {best_score})")
            else:
                logger.debug(f"No se encontró un módulo de Metasploit para '{title}' (EDB-ID: {edb_id})")

        return mapping

    def save_mapping(self, mapping: Dict[str, str]):
        """Guarda el mapeo en un archivo JSON."""
        try:
            with open(self.mapping_file, "w") as f:
                json.dump(mapping, f, indent=2)
            logger.info(f"Mapeo guardado en {self.mapping_file}")
        except Exception as e:
            logger.error(f"Error al guardar el mapeo: {e}")
            raise

    def run(self):
        """Genera el mapeo de exploits a módulos de Metasploit."""
        logger.info("Generando mapeo de exploits a módulos de Metasploit...")

        # Inicializar la base de datos de Metasploit
        self.initialize_msfdb()

        # Obtener exploits de searchsploit
        exploits = self.get_searchsploit_exploits()
        if not exploits:
            logger.error("No se pudieron obtener los exploits de searchsploit, abortando...")
            raise RuntimeError("No se pudieron obtener los exploits de searchsploit")

        # Obtener módulos de Metasploit
        modules = self.get_metasploit_modules()
        if not modules:
            logger.error("No se pudieron obtener los módulos de Metasploit, abortando...")
            raise RuntimeError("No se pudieron obtener los módulos de Metasploit")

        # Generar el mapeo
        self.exploit_mapping = self.map_exploits_to_modules(exploits, modules)
        if not self.exploit_mapping:
            logger.warning("No se generaron mapeos, el diccionario está vacío")
            return

        # Guardar el mapeo
        self.save_mapping(self.exploit_mapping)
        logger.info(f"Generados {len(self.exploit_mapping)} mapeos")


if __name__ == "__main__":
    try:
        generator = ExploitMappingGenerator()
        generator.run()
    except Exception as e:
        logger.error(f"Error en la ejecución del generador: {e}")
        # No hacemos exit(1), solo registramos el error y continuamos
        logger.info("Continuando ejecución a pesar del error en generate_exploit_mapping.py")