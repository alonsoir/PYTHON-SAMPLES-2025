# generate_exploit_mapping.py
import json
import os
import subprocess
import re
from typing import Dict, List
from datetime import datetime

import logging

# Configuración de logging
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger("ExploitMappingGenerator")
results_dir = "/results"
os.makedirs(results_dir, exist_ok=True)
log_file = "/results/mapping_generator.log"
file_handler = logging.FileHandler(log_file)
file_handler.setLevel(logging.DEBUG)
formatter = logging.Formatter('%(asctime)s [%(name)s] %(levelname)s: %(message)s')
file_handler.setFormatter(formatter)
logger.addHandler(file_handler)


class ExploitMappingGenerator:
    def __init__(self):
        self.msfconsole_path = "/usr/bin/msfconsole"
        self.mapping_file = "/results/exploit_mapping.json"
        self.exploit_mapping: Dict[str, str] = {}

    def get_searchsploit_exploits(self) -> List[Dict]:
        """Obtiene la lista de exploits de searchsploit en formato JSON."""

        try:
            cmd = ["searchsploit", "-j", "--exclude", "dos"]
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
            if result.returncode != 0:
                logger.error(f"Error al ejecutar searchsploit: {result.stderr}")
                return []

            exploits = json.loads(result.stdout).get("RESULTS_EXPLOIT", [])
            logger.info(f"Encontrados {len(exploits)} exploits en searchsploit")
            return exploits
        except Exception as e:
            logger.error(f"Error al obtener exploits de searchsploit: {e}")
            return []

    def get_metasploit_modules(self) -> List[Dict]:
        """
        Obtiene la lista de módulos de Metasploit ejecutando un script en msfconsole.
        Devuelve una lista de diccionarios con nombre, descripción, plataformas y referencias.
        """

        try:
            # Crear un script temporal para listar módulos
            temp_script = f"/tmp/list_modules_{datetime.now().strftime('%Y%m%d_%H%M%S')}.rb"
            with open(temp_script, "w") as f:
                f.write("""
                framework.modules.each do |name, mod|
                 next unless name.start_with?('exploit/')
                 begin
                 m = framework.modules.create(name)
                 if m
                 refs = m.references.map { |r| r.to_s }.join(',')
                 puts "MODULE: #{name}|#{m.description}|#{m.platform.join(',')}|#{refs}"
                 end
                 rescue => e
                 puts "ERROR: #{name}|#{e.message}"
                 end
                end
                """)

            # Ejecutar msfconsole con el script
            output_file = f"/tmp/msf_modules_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
            command = [self.msfconsole_path, "-q", "-o", output_file, "-r", temp_script]
            process = subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, timeout=300)

            if process.returncode != 0:
                logger.error(f"Error al listar módulos de Metasploit: {process.stderr}")
                return []

            # Leer la salida
            modules = []
            with open(output_file, "r") as f:
                for line in f:
                    if line.startswith("MODULE:"):
                        parts = line.strip().split("|")
                        if len(parts) >= 4:
                            name = parts[1]
                            description = parts[2]
                            platforms = parts[3].split(",")
                            references = parts[4].split(",") if len(parts) > 4 else []
                            modules.append({
                                "name": name,
                                "description": description,
                                "platforms": platforms,
                                "references": references
                            })

            # Limpiar archivos temporales
            os.remove(temp_script)
            os.remove(output_file)

            logger.info(f"Encontrados {len(modules)} módulos de Metasploit")
            return modules
        except Exception as e:
            logger.error(f"Error al obtener módulos de Metasploit: {e}")
            return []

    def map_exploits_to_modules(self, exploits: List[Dict], modules: List[Dict]) -> Dict[str, str]:
        """
        Mapea exploits de searchsploit a módulos de Metasploit usando coincidencias de palabras clave.
        """

        mapping = {}
        for exploit in exploits:
            title = exploit.get("Title", "").lower()
            edb_id = exploit.get("EDB-ID", "unknown")
            platform = exploit.get("Platform", "").lower()

            # Palabras clave del título
            keywords = set(re.findall(r'\w+', title))
            keywords.update([platform])  # Agregar la plataforma como palabra clave

            # Buscar coincidencias en los módulos de Metasploit
            best_match = None
            best_score = 0

            for module in modules:
                module_name = module["name"].lower()
                description = module["description"].lower()
                module_platforms = [p.lower() for p in module["platforms"]]
                references = [r.lower() for r in module["references"]]

                # Calcular un puntaje de coincidencia
                score = 0
                # Coincidencia en el título/descripción
                for keyword in keywords:
                    if keyword in module_name or keyword in description:
                        score += 2
                    if keyword in " ".join(module_platforms):
                        score += 1
                # Coincidencia en referencias (e.g., EDB-ID)
                if f"edb-{edb_id}" in references:
                    score += 5  # Alta prioridad si hay coincidencia de EDB-ID

                if score > best_score:
                    best_score = score
                    best_match = module["name"]

            # Si se encontró una coincidencia razonable, agregar al mapeo
            if best_score >= 3:  # Umbral de coincidencia
                # Normalizar la clave del mapeo
                key = " ".join(sorted([k for k in keywords if k not in ["exploit", "vulnerability", "remote", "local"]])).strip()
                if key:
                    mapping[key] = best_match
                    logger.debug(f"Mapeado '{key}' (EDB-ID: {edb_id}) a '{best_match}' (score: {best_score})")
            else:
                logger.debug(f"No se encontró un módulo de Metasploit para '{title}' (EDB-ID: {edb_id})")

        return mapping

    def save_mapping(self, mapping: Dict[str, str]):
        """Guarda el mapeo en un archivo JSON."""

        try:
            with open(self.mapping_file, "w") as f:
                json.dump(mapping, f, indent=2)
            logger.info(f"Mapeo guardado en {self.mapping_file}")
        except Exception as e:
            logger.error(f"Error al guardar el mapeo: {e}")

    def run(self):
        """Genera el mapeo de exploits a módulos de Metasploit."""

        logger.info("Generando mapeo de exploits a módulos de Metasploit...")

        # Obtener exploits de searchsploit
        exploits = self.get_searchsploit_exploits()
        if not exploits:
            logger.error("No se pudieron obtener los exploits de searchsploit, abortando...")
            return

        # Obtener módulos de Metasploit
        modules = self.get_metasploit_modules()
        if not modules:
            logger.error("No se pudieron obtener los módulos de Metasploit, abortando...")
            return

        # Generar el mapeo
        self.exploit_mapping = self.map_exploits_to_modules(exploits, modules)
        if not self.exploit_mapping:
            logger.warning("No se generaron mapeos, el diccionario está vacío")
            return

        # Guardar el mapeo
        self.save_mapping(self.exploit_mapping)
        logger.info(f"Generados {len(self.exploit_mapping)} mapeos")


if __name__ == "__main__":
    generator = ExploitMappingGenerator()
    generator.run()